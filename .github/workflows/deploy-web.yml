name: Deploy Web to Vercel

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      run_id:
        description: "GitHub Actions run ID containing the artifacts (optional)"
        required: false
        type: string
      build_id:
        description: "Build ID to deploy (optional)"
        required: false
        type: string
      confirm:
        description: 'Type "yes" to confirm deployment'
        required: true
        type: string

# Add permissions block
permissions:
  contents: read
  actions: read

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check confirmation
        if: ${{ inputs.confirm != 'yes' }}
        run: |
          echo "Deployment not confirmed. Please set confirm input to 'yes' to proceed."
          exit 1

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Find latest successful build workflow run
        if: ${{ inputs.run_id == '' }}
        id: find_build
        run: |
          # Find the latest successful build workflow run
          LATEST_RUN_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build.yml/runs?status=success&per_page=1" | \
            jq -r '.workflow_runs[0].id')

          if [ "$LATEST_RUN_ID" == "null" ]; then
            echo "No successful build workflow run found."
            exit 1
          fi

          echo "Found latest successful build workflow run: $LATEST_RUN_ID"
          echo "run_id=$LATEST_RUN_ID" >> $GITHUB_OUTPUT

      - name: Set run ID
        id: set_run_id
        run: |
          if [ "${{ inputs.run_id }}" != "" ]; then
            echo "Using provided run ID: ${{ inputs.run_id }}"
            echo "run_id=${{ inputs.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "Using latest successful build run ID: ${{ steps.find_build.outputs.run_id }}"
            echo "run_id=${{ steps.find_build.outputs.run_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Download build info
        uses: actions/download-artifact@v4
        with:
          name: build-info
          repository: ${{ github.repository }}
          run-id: ${{ steps.set_run_id.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: ./

      - name: Set build ID
        id: set_build_id
        run: |
          if [ "${{ inputs.build_id }}" != "" ]; then
            echo "Using provided build ID: ${{ inputs.build_id }}"
            echo "build_id=${{ inputs.build_id }}" >> $GITHUB_OUTPUT
          elif [ -f "build-info.json" ]; then
            BUILD_ID=$(jq -r '.build_id' build-info.json)
            echo "Using build ID from build-info.json: $BUILD_ID"
            echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
          else
            echo "Using run ID as build ID: ${{ steps.set_run_id.outputs.run_id }}"
            echo "build_id=${{ steps.set_run_id.outputs.run_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Download Web deployment artifact
        uses: actions/download-artifact@v4
        with:
          name: web-artifact
          repository: ${{ github.repository }}
          run-id: ${{ steps.set_run_id.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: ./

      - name: Extract Web deployment artifact
        run: |
          mkdir -p deploy-web
          tar -xzf web-artifact.tar.gz -C deploy-web
          echo "Current working directory: $(pwd)"
          echo "Contents of deploy-web directory:"
          ls -la deploy-web
          echo "Full directory structure:"
          find deploy-web -type d | sort
          echo "Files with package.json:"
          find deploy-web -name "package.json" | sort
          echo "Next.js related files:"
          find deploy-web -name "next.config.js" | sort

      - name: Install Vercel CLI
        run: npm install -g vercel

      - name: Deploy to Vercel
        id: deploy
        run: |
          # Find the actual Next.js app directory
          NEXT_CONFIG_FILES=$(find deploy-web -name "next.config.js" | sort)

          if [ -n "$NEXT_CONFIG_FILES" ]; then
            # Use the first next.config.js file found
            APP_DIR=$(dirname $(echo "$NEXT_CONFIG_FILES" | head -n 1))
            echo "Found Next.js app directory via next.config.js: $APP_DIR"
          elif [ -d "deploy-web/apps/web" ]; then
            APP_DIR="deploy-web/apps/web"
            echo "Found Next.js app directory at standard path: $APP_DIR"
          elif [ -d "deploy-web/apps/web-app" ]; then
            APP_DIR="deploy-web/apps/web-app"
            echo "Found Next.js app directory at alternate path: $APP_DIR"
          elif [ -d "deploy-web/web" ]; then
            APP_DIR="deploy-web/web"
            echo "Found Next.js app directory at simple path: $APP_DIR"
          else
            # Try to find any directory with a package.json that looks like a Next.js app
            NEXT_PACKAGE_FILES=$(find deploy-web -name "package.json" -exec grep -l "next" {} \; | sort)
            
            if [ -n "$NEXT_PACKAGE_FILES" ]; then
              APP_DIR=$(dirname $(echo "$NEXT_PACKAGE_FILES" | head -n 1))
              echo "Found Next.js app directory via package.json: $APP_DIR"
            else
              echo "ERROR: Could not find Next.js app directory"
              echo "Contents of deploy-web directory:"
              ls -la deploy-web
              echo "All package.json files:"
              find deploy-web -name "package.json" -exec cat {} \; | grep -A 5 -B 5 "dependencies"
              exit 1
            fi
          fi

          echo "Using Next.js app directory: $APP_DIR"
          echo "Contents of app directory:"
          ls -la "$APP_DIR"

          # Create the expected directory structure for Vercel
          # The error message indicates Vercel is looking for: ~/work/SupplyChainSystem/SupplyChainSystem/deploy-web/apps/web
          mkdir -p deploy-web/apps/web

          # Copy all files from the detected app directory to the expected path
          if [ "$APP_DIR" != "deploy-web/apps/web" ]; then
            echo "Copying files from $APP_DIR to deploy-web/apps/web"
            cp -r "$APP_DIR"/* deploy-web/apps/web/
            cp -r "$APP_DIR"/.* deploy-web/apps/web/ 2>/dev/null || true
            
            # Change to the expected directory
            cd deploy-web/apps/web
          else
            # Already in the correct directory
            cd "$APP_DIR"
          fi

          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la

          # Set environment-specific variables
          VERCEL_ARGS="--token ${{ secrets.VERCEL_TOKEN }} --yes"

          # Create .vercel directory and project.json for project linking
          mkdir -p .vercel
          echo "{\"projectId\": \"${{ secrets.VERCEL_PROJECT_ID }}\", \"orgId\": \"${{ secrets.VERCEL_ORG_ID }}\"}" > .vercel/project.json

          if [ "${{ inputs.environment }}" == "production" ]; then
            VERCEL_ARGS="$VERCEL_ARGS --prod"
            DEPLOYMENT_URL=$(vercel $VERCEL_ARGS --env NEXT_PUBLIC_API_URL=https://supply-chain-system-api.fly.dev | grep -o 'https://.*')
          else
            DEPLOYMENT_URL=$(vercel $VERCEL_ARGS --env NEXT_PUBLIC_API_URL=https://staging-supply-chain-system-api.fly.dev | grep -o 'https://.*')
          fi

          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $DEPLOYMENT_URL"

      - name: Verify Deployment
        run: |
          DEPLOYMENT_URL="${{ steps.deploy.outputs.deployment-url }}"

          echo "Verifying deployment at URL: $DEPLOYMENT_URL"

          # Wait for the app to be ready
          echo "Waiting for the app to be ready..."
          sleep 10

          # Check the health endpoint
          MAX_RETRIES=6
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $DEPLOYMENT_URL || echo "failed")
            
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "Health check passed! Application is running."
              exit 0
            else
              echo "Health check failed with status: $HTTP_STATUS. Retrying in 10 seconds..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              sleep 10
            fi
          done

          echo "Health check failed after $MAX_RETRIES attempts."
          echo "Deployment verification failed."
          exit 1
